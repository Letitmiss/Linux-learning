### [目录](https://github.com/Letitmiss/Linux-learning/blob/master/README.md)
### [上一节 第10章 vim程序编辑器](https://github.com/Letitmiss/Linux-learning/blob/master/blog/10.vim.md)

# 认识与学习BASH

## 认识BASH这个Shell
### 1.硬件、核心与shell

* 管理整个计算硬件的其实是操作系统的核心（kernel），用户的操作不能直接与kernel沟通，可以通过shell给kernel下达指令，kernel控制硬件来工作，所以shell就是可以让我们更方便的来指挥核心（kernel）工作；
### 2.为何学习shell？
* 学了才会知道，不学就永远不会知道

# Shell 变量的功能
## 变量的显示与设置 
* 变量的定义 ：编程语言基本都一样
* 输出变量： echo $PATH,  echo的功能很多后面介绍
## 变量的定义规则
* 变量与变量的内容用=链接 myname=gaocong
* 等号两边不能有空格或者变量名不能直接空格，**错误实例 myname = gaocng  或 myname=gao cong**
* 变量名只能是英文字母与数字，但是数字不能开头, **错误实例 2myname=gaocong**
* 变量内容若有空格符，可以使用双引号或者单引号将变量内容结合起来
    * 双引号内有特殊字符$代表变量，可以保持变量的属性
    * 单引号内有特殊字符则仅作为一般纯文本，不做变量解析
* 可以使用跳脱字符（转义字符），将Enter，$n,\,空格等变成一般字符
* 一串指令用需要使用命令提供信息，使用反单引号或者$(指令)可以显示命令执行后的结果
* 若该变量为扩增变量内容时，可以用"$变量名称"或者${变量}累加内容 **实例 PATH="$PATH":/home/bin**
* 若该变量需要在其他子程序中执行，则需要以export 来使得变量变成环境变量 **export PATH**
* 通常大写字符为系统默认变量，自行设置的变量使用小写字母，个人兴趣，不过也是默认规定
* 取消变量的方法为为使用 unset ，unset 变量名
#### 实际的例子展示
````
lfg1000708009:/home/gaocong # myname=gao's cong
> 
> lfg1000708009:/home/gaocong # echo $myname

# 单引号与双引号必须要成对，有一个单引号，enter之后还没有推出输入，ctrl-c 推出，输出变量为空，设置变量失败
lfg1000708009:/home/gaocong # myname="gao's cong"  <== 设置成功
lfg1000708009:/home/gaocong # echo $myname
gao's cong                              
lfg1000708009:/home/gaocong # myname='gao's cong' <== 设置失败，有单引号不成对
lfg1000708009:/home/gaocong # myname=gao\'s\ cong <== 使用转义字符

# 变量累加
lfg1000708009:/home/gaocong # PATH=$PATH:/home/gaocong/bin
lfg1000708009:/home/gaocong # PATH="$PATH":/home/gaocong/bin
lfg1000708009:/home/gaocong # PATH=${PATH}:/home/gaocong/bin
# 以上三种都是Ok的

# 将name多出多出一个yes
lfg1000708009:/home/gaocong # name=gaocong
lfg1000708009:/home/gaocong # name=$nameyes
# 没用双引号将name变量括起来，这样是将nameyes变量设置给name，没有nameyes这个变量是时，那么久变为空值了
lfg1000708009:/home/gaocong # name=gaocong
lfg1000708009:/home/gaocong # name="$name"yes  <== 正确操作
lfg1000708009:/home/gaocong # echo $name
gaocongyes
lfg1000708009:/home/gaocong # name=${name}yes  <== 正确操作，这样为最佳操作
lfg1000708009:/home/gaocong # echo $name
gaocongyesyes

# 如何让设置的name用在下一个shell的程序中？
lfg1000708009:/home/gaocong # name=gaocong  <== 设定变量
lfg1000708009:/home/gaocong # echo $name
gaocong
lfg1000708009:/home/gaocong # bash          <== 进入shell子程序
lfg1000708009:/home/gaocong # echo $name    <== 查看变量为空

lfg1000708009:/home/gaocong # exit         <== 离开shell子程序
exit
lfg1000708009:/home/gaocong # export name   <== export 使得这个变量可以在子shell中使用
lfg1000708009:/home/gaocong # bash
lfg1000708009:/home/gaocong # echo $name     <== 进入子shell 查看变量是有的

gaocong
lfg1000708009:/home/gaocong # exit      <== 离开shell子程序
exit

# 如何进入目前的核心目录
lfg1000708009:~ # cd /lib/modules/`uname -r`/kernel    <== 进入核心目录 
lfg1000708009:/lib/modules/3.0.101-0.47.71-default/kernel # cd -
/root
lfg1000708009:~ # cd /lib/modules/$(uname -r)/kernel    <== 进入核心目录
lfg1000708009:/lib/modules/3.0.101-0.47.71-default/kernel # 
# 反单引号和$() 的命令会先执行
````
##  环境变量的功能

### 用env查看环变量
* env是enviroment的缩写
````
[root@localhost ~]# env
HOSTNAME=localhost.localdomain  <== 主机名
TERM=xterm                      <== 终端使用什么类型的环境
SHELL=/bin/bash                  <== 目前使用的shell程序
HISTSIZE=1000                    <== 记录历史命令的条数
SSH_CLIENT=192.168.253.1 50046 22 <== 客户端信息
QTDIR=/usr/lib64/qt-3.3
QTINC=/usr/lib64/qt-3.3/include
SSH_TTY=/dev/pts/0
JRE_HOME=/usr/java/jdk1.7.0_79/jre
USER=root
MAIL=/var/spool/mail/root          <== mail地址
PATH=/usr/java/jdk1.7.0_79/bin:/usr/java/jdk1.7.0_79/jre/bin:/home/develop/apache-maven-3.5.0/bin:/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
PWD=/root
JAVA_HOME=/usr/java/jdk1.7.0_79  <== java配置
LANG=zh_CN.UTF-8                 <==语系配置 或者zh_CN.gb2312

#RANDOM 随机数.介于0-32767 之间,echo $RANDOM 系统会给出一个随机数
#输出一个0-9的随机数
[root@localhost ~]# declare -i number=$RANDOM*10/32676 ; echo $number
8
````
### set 查看所有变量
````
lfg1000708009:~ # set

AGENT_JRE_HOME=/opt/uniagent/jre  
BASH=/bin/bash                            <== shell位置
BASH_VERSINFO=([0]="3" [1]="2" [2]="51" [3]="1" [4]="release" [5]="x86_64-suse-linux-gnu")
BASH_VERSION='3.2.51(1)-release'          <== shell 版本
COLORTERM=1
COLUMNS=174                               <==目前终端机的字符长度
CONSOLE_MAGIC='(K'
CPU=x86_64
CSHEDIT=emacs
CVS_RSH=ssh
DIRSTACK=()
ENV=/etc/bash.bashrc
EUID=0
FROM_HEADER=
GROUPS=()
G_BROKEN_FILENAMES=1
HISTCONTROL=ignoreboth
HISTFILE=/root/.bash_history
HISTFILESIZE=1000
HISTSIZE=1000
HISTTIMEFORMAT='%F %H:%M:%S '
HOME=/root
HOST=lfg1000708009
HOSTFILE=
HOSTNAME=lfg1000708009
LANG=en_US.UTF-8
LANGUAGE=CN
LC_CTYPE=en_US.UTF-8
MAIL=/var/mail/root
MAILCHECK=60
PPID=28599                               <== 父进程PID
PS1='[\u\h \W] \$'  <== 命令提示符
PS2='> '
PS4='+ '
````
### 主要说明几个
* PS1 命令提示符
   * \d 显示日期，日期格式"Mon Feb 2"
   * \H 显示完整主机名 "www.gaocong.com"
   * \h 仅显示主机名在第一个小数点之前的名字,显示www
   * \t 显示时间 24小时 HH:MM:SS
   * \T 显示时间 12小时 HH:MM:SS
   * \A 显示时间 24小时 HH:MM
   * \@ 显示时间 24小时 am/pm 
   * \u 目前用户的账号名称
   * \v bash的版本信息
   * \w 显示完成工作目录名称
   * \W 利用basename函数，获取工作目录，只会显示最后一个目录名
   * \# 执行第几个命令
   * \$ 提示符如果是root就是# 其他用户显示$
* ?上一个命令执行之后传回值,默认执行成功返回0，执行失败返回非0
````
lfg1000708009:~ # echo $HOME            <== 执行成功
/root                         
lfg1000708009:~ # echo $?               <== 输出0
0
lfg1000708009:~ # cd /home/no          <== 执行失败
-bash: cd: /home/no: No such file or directory
lfg1000708009:~ # echo $?               <== 输出非0，不一定是1
1
lfg1000708009:~ # echo $?               <== 上一个命令执行成功 输出0
0
````
* OSTYPE,HOSTTYPE,MACHTYPE 主机硬件和内核等级
   * CPU主要分为32、64 位，其中32位又分为 i386、i586、i686，64位称为x86_64,不同CPU的命令集不一样，所以安装软件有这四种之分，在x86_64的硬件安装i386的Linux是ok的，但是无法在i686上安装x86_64的linux操作系统
````
lfg1000581805:/home/dminstall # set | grep "OSTYPE"
OSTYPE=linux
msg='2017-10-24 23:00:23 set | grep "OSTYPE,HOSTTYPE,MACHTYPE"'
lfg1000581805:/home/dminstall # set | grep "HOSTTYPE"
HOSTTYPE=x86_64
lfg1000581805:/home/dminstall # set | grep "MACHTYPE"
MACHTYPE=x86_64-suse-linux
lfg1000581805:/home/dminstall # 
````
